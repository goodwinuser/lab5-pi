/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = false;}PARSER_BEGIN(MathGrammar)package parser;import calculator.MathExpression;import calculator.BinaryExpression;import calculator.UnaryExpression;import calculator.BinaryOperator;import calculator.UnaryOperator;import calculator.Number;public class MathGrammar{  public static void main(String args []) throws ParseException, parser.ParseException  {    MathGrammar parser = new MathGrammar(System.in);    System.out.println("Calculator TEST v0.1");    while (true)    {      System.out.print(">");      MathExpression expr = parser.one_line();      System.out.println("=\n" + expr.evaluate());    }  }}PARSER_END(MathGrammar)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN : /* OPERATORS */{  < PLUS : "+" >| < MINUS : "-" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < LOG : "log" >}TOKEN :{  < CONSTANT :    (< DIGIT >)+    (      "." (< DIGIT >)*    )? >| < #DIGIT : [ "0"-"9" ] >  }MathExpression one_line() :{  MathExpression expr;}{  expr = sum() < EOF >  {    return expr;  }| < EOF >  {    return null;  }}MathExpression sum() :{  MathExpression expr, expr2;}{  expr = term()  (    < PLUS > expr2 = term()    {      expr = new BinaryExpression(expr, expr2, BinaryOperator.ADDITION);    }  | < MINUS > expr2 = term()    {      expr = new BinaryExpression(expr, expr2, BinaryOperator.SUBSTRACTION);    }  )*  {    return expr;  }}MathExpression term() :{  MathExpression expr, expr2;}{  expr = unary()  (    < MULTIPLY > expr2 = unary()    {      expr = new BinaryExpression(expr, expr2, BinaryOperator.MULTIPLICATION);    }  | < DIVIDE > expr2 = unary()    {      expr = new BinaryExpression(expr, expr2, BinaryOperator.DIVISION);    }  )*  {    return expr;  }}MathExpression unary() :{  MathExpression expr;}{  (    < MINUS > expr = element()    {      expr = new UnaryExpression(expr, UnaryOperator.MINUS);    }  | < LOG > expr = element()    {      expr = new UnaryExpression(expr, UnaryOperator.LOG);    }  | expr = element()  )  {    return expr;  }}MathExpression element() :{  Token t;  MathExpression expr;}{  t = < CONSTANT >  {    return new Number(Float.parseFloat(t.image));  }| "(" expr = sum() ")"  {    return expr;  }}